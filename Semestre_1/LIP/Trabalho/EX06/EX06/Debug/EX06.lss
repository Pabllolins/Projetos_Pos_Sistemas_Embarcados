
EX06.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002e  00800100  0000028c  00000320  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000028c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000067  0080012e  0080012e  0000034e  2**0
                  ALLOC
  3 .debug_aranges 00000068  00000000  00000000  0000034e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000000c0  00000000  00000000  000003b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000303  00000000  00000000  00000476  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000001e2  00000000  00000000  00000779  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000039a  00000000  00000000  0000095b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000090  00000000  00000000  00000cf8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000152  00000000  00000000  00000d88  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000016e  00000000  00000000  00000eda  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000a0  00000000  00000000  00001048  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	UDR0 = data;								// Envia o dado pela porta serial
}

//-------------------------------------------------------------------------------------------------------
unsigned char USART_Receive()
{
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_18>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ec e8       	ldi	r30, 0x8C	; 140
  7c:	f2 e0       	ldi	r31, 0x02	; 2
  7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
  84:	ae 32       	cpi	r26, 0x2E	; 46
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
  8a:	11 e0       	ldi	r17, 0x01	; 1
  8c:	ae e2       	ldi	r26, 0x2E	; 46
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a5 39       	cpi	r26, 0x95	; 149
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 96 00 	call	0x12c	; 0x12c <main>
  9e:	0c 94 44 01 	jmp	0x288	; 0x288 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_18>:

/**
 * Vetor de Interrupção USART RX
 */
ISR( USART_RX_vect )
{
  a6:	1f 92       	push	r1
  a8:	0f 92       	push	r0
  aa:	0f b6       	in	r0, 0x3f	; 63
  ac:	0f 92       	push	r0
  ae:	11 24       	eor	r1, r1
  b0:	2f 93       	push	r18
  b2:	8f 93       	push	r24
  b4:	9f 93       	push	r25
  b6:	ef 93       	push	r30
  b8:	ff 93       	push	r31
	 *  FE0 = Frame Error;
	 *  DOR0 = Data OverRun;
	 *  UPE0 = USART Parity Error;
	 */
	 
	 data = UDR0;
  ba:	20 91 c6 00 	lds	r18, 0x00C6
	
	if((UCSR0A & ((1 << FE0) | (1 << DOR0) | (1 << UPE0))) == 0)
  be:	80 91 c0 00 	lds	r24, 0x00C0
  c2:	8c 71       	andi	r24, 0x1C	; 28
  c4:	49 f5       	brne	.+82     	; 0x118 <__vector_18+0x72>
	{

		/**
		 * Buffer cheio? Caso sim, reinicia indice
		 */		
		if(indice >= sizeof(usart_rx_buffer))
  c6:	80 91 2e 01 	lds	r24, 0x012E
  ca:	90 91 2f 01 	lds	r25, 0x012F
  ce:	84 36       	cpi	r24, 0x64	; 100
  d0:	91 05       	cpc	r25, r1
  d2:	20 f0       	brcs	.+8      	; 0xdc <__vector_18+0x36>
		{
			indice = 0;
  d4:	10 92 2f 01 	sts	0x012F, r1
  d8:	10 92 2e 01 	sts	0x012E, r1
		}
		
		/**
		 * Caractere indicador de fim de frame;
		 */
		if( data == '\n' )
  dc:	2a 30       	cpi	r18, 0x0A	; 10
  de:	79 f4       	brne	.+30     	; 0xfe <__vector_18+0x58>
		{
			usart_rx_buffer[indice] = '\0'; 
  e0:	e0 91 2e 01 	lds	r30, 0x012E
  e4:	f0 91 2f 01 	lds	r31, 0x012F
  e8:	ef 5c       	subi	r30, 0xCF	; 207
  ea:	fe 4f       	sbci	r31, 0xFE	; 254
  ec:	10 82       	st	Z, r1
			frame_status = 1; 
  ee:	81 e0       	ldi	r24, 0x01	; 1
  f0:	80 93 30 01 	sts	0x0130, r24
			indice = 0;
  f4:	10 92 2f 01 	sts	0x012F, r1
  f8:	10 92 2e 01 	sts	0x012E, r1
  fc:	0d c0       	rjmp	.+26     	; 0x118 <__vector_18+0x72>
		} 
		/* Armazena os bytes recebidos no buffer */
		else {
			usart_rx_buffer[indice++] = data; 
  fe:	80 91 2e 01 	lds	r24, 0x012E
 102:	90 91 2f 01 	lds	r25, 0x012F
 106:	fc 01       	movw	r30, r24
 108:	ef 5c       	subi	r30, 0xCF	; 207
 10a:	fe 4f       	sbci	r31, 0xFE	; 254
 10c:	20 83       	st	Z, r18
 10e:	01 96       	adiw	r24, 0x01	; 1
 110:	90 93 2f 01 	sts	0x012F, r25
 114:	80 93 2e 01 	sts	0x012E, r24
		}
	
	}
}
 118:	ff 91       	pop	r31
 11a:	ef 91       	pop	r30
 11c:	9f 91       	pop	r25
 11e:	8f 91       	pop	r24
 120:	2f 91       	pop	r18
 122:	0f 90       	pop	r0
 124:	0f be       	out	0x3f, r0	; 63
 126:	0f 90       	pop	r0
 128:	1f 90       	pop	r1
 12a:	18 95       	reti

0000012c <main>:
/**
 * Função principal e de entrada do programa;
 */
int main( void )
{
 12c:	3f 92       	push	r3
 12e:	4f 92       	push	r4
 130:	5f 92       	push	r5
 132:	6f 92       	push	r6
 134:	7f 92       	push	r7
 136:	8f 92       	push	r8
 138:	9f 92       	push	r9
 13a:	af 92       	push	r10
 13c:	bf 92       	push	r11
 13e:	cf 92       	push	r12
 140:	df 92       	push	r13
 142:	ef 92       	push	r14
 144:	ff 92       	push	r15
 146:	0f 93       	push	r16
 148:	1f 93       	push	r17
 14a:	cf 93       	push	r28
 14c:	df 93       	push	r29
    uint8_t aux = 0;
	/**
	 * Para usar qualquer GPIO antes é necessário configurar o sentido (entrada ou saída);
	 * Configura todos os pinos do PORTB como saída; 
	 */
    Set_bit( DDRB, LED_BUILDING );  //Pino RB5 como saída;
 14e:	e4 e2       	ldi	r30, 0x24	; 36
 150:	f0 e0       	ldi	r31, 0x00	; 0
 152:	80 81       	ld	r24, Z
 154:	80 62       	ori	r24, 0x20	; 32
 156:	80 83       	st	Z, r24
    Clr_bit( DDRD, BUTTON_1 ); 		//Pino PD2 como entrada; 
 158:	ea e2       	ldi	r30, 0x2A	; 42
 15a:	f0 e0       	ldi	r31, 0x00	; 0
 15c:	80 81       	ld	r24, Z
 15e:	8b 7f       	andi	r24, 0xFB	; 251
 160:	80 83       	st	Z, r24
	Set_bit( PORTD, BUTTON_1 ); 	//Pull UP em PD2
 162:	eb e2       	ldi	r30, 0x2B	; 43
 164:	f0 e0       	ldi	r31, 0x00	; 0
 166:	80 81       	ld	r24, Z
 168:	84 60       	ori	r24, 0x04	; 4
 16a:	80 83       	st	Z, r24
	/**
	 * Inicializa a Uart
	 */
	USART_Init(); 
 16c:	0e 94 1a 01 	call	0x234	; 0x234 <USART_Init>
	USART_StrTx("Hello\r\n");
 170:	80 e0       	ldi	r24, 0x00	; 0
 172:	91 e0       	ldi	r25, 0x01	; 1
 174:	0e 94 2f 01 	call	0x25e	; 0x25e <USART_StrTx>
	/**
	 * Habilita a interrupção Serial;
	 * sei() -> habilita a chave geral das interrupções;
	 * cli() -> desabilita a chave geral das interrupções;
	 */	
	sei(); 
 178:	78 94       	sei
	USART_rxIE();   
 17a:	0e 94 3e 01 	call	0x27c	; 0x27c <USART_rxIE>
 17e:	10 e0       	ldi	r17, 0x00	; 0
		
		ENTER_CRITICAL();
		{
			if( frame_status )
			{
				USART_StrTx( (char*)usart_rx_buffer ); 
 180:	0f 2e       	mov	r0, r31
 182:	f1 e3       	ldi	r31, 0x31	; 49
 184:	cf 2e       	mov	r12, r31
 186:	f1 e0       	ldi	r31, 0x01	; 1
 188:	df 2e       	mov	r13, r31
 18a:	f0 2d       	mov	r31, r0
		EXIT_CRITICAL();
		
		/**
		 * Button pressionado?
		 */
    	if( !Tst_bit( PIND, BUTTON_1 ) && aux == 0 )  
 18c:	0f 2e       	mov	r0, r31
 18e:	f9 e2       	ldi	r31, 0x29	; 41
 190:	ef 2e       	mov	r14, r31
 192:	ff 24       	eor	r15, r15
 194:	f0 2d       	mov	r31, r0
    	{
			
			USART_StrTx("Button Pressionado.\r\n");
 196:	0f 2e       	mov	r0, r31
 198:	f8 e0       	ldi	r31, 0x08	; 8
 19a:	6f 2e       	mov	r6, r31
 19c:	f1 e0       	ldi	r31, 0x01	; 1
 19e:	7f 2e       	mov	r7, r31
 1a0:	f0 2d       	mov	r31, r0
			
    		/**
    		 * Inverte o estado lógico do led building;
    		 */
			Cpl_bit( PORTB, LED_BUILDING ); 
 1a2:	0f 2e       	mov	r0, r31
 1a4:	f5 e2       	ldi	r31, 0x25	; 37
 1a6:	af 2e       	mov	r10, r31
 1a8:	bb 24       	eor	r11, r11
 1aa:	f0 2d       	mov	r31, r0
 1ac:	00 e2       	ldi	r16, 0x20	; 32
 1ae:	0f 2e       	mov	r0, r31
 1b0:	f8 ee       	ldi	r31, 0xE8	; 232
 1b2:	8f 2e       	mov	r8, r31
 1b4:	f3 e0       	ldi	r31, 0x03	; 3
 1b6:	9f 2e       	mov	r9, r31
 1b8:	f0 2d       	mov	r31, r0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1ba:	c0 e9       	ldi	r28, 0x90	; 144
 1bc:	d1 e0       	ldi	r29, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1be:	33 24       	eor	r3, r3
 1c0:	33 94       	inc	r3
		/**
		 * Button solto?
		 */
		if( Tst_bit( PIND, BUTTON_1 ) && aux == 1 )
		{
			USART_StrTx("Button Solto.\r\n");
 1c2:	0f 2e       	mov	r0, r31
 1c4:	fe e1       	ldi	r31, 0x1E	; 30
 1c6:	4f 2e       	mov	r4, r31
 1c8:	f1 e0       	ldi	r31, 0x01	; 1
 1ca:	5f 2e       	mov	r5, r31
 1cc:	f0 2d       	mov	r31, r0
 1ce:	01 c0       	rjmp	.+2      	; 0x1d2 <main+0xa6>
	 * Habilita a interrupção Serial;
	 * sei() -> habilita a chave geral das interrupções;
	 * cli() -> desabilita a chave geral das interrupções;
	 */	
	sei(); 
	USART_rxIE();   
 1d0:	10 e0       	ldi	r17, 0x00	; 0
	
    for(;;) 
    {
		
		ENTER_CRITICAL();
 1d2:	f8 94       	cli
		{
			if( frame_status )
 1d4:	80 91 30 01 	lds	r24, 0x0130
 1d8:	88 23       	and	r24, r24
 1da:	29 f0       	breq	.+10     	; 0x1e6 <main+0xba>
			{
				USART_StrTx( (char*)usart_rx_buffer ); 
 1dc:	c6 01       	movw	r24, r12
 1de:	0e 94 2f 01 	call	0x25e	; 0x25e <USART_StrTx>
				
				frame_status = 0; 
 1e2:	10 92 30 01 	sts	0x0130, r1
			}
		}
		EXIT_CRITICAL();
 1e6:	78 94       	sei
		
		/**
		 * Button pressionado?
		 */
    	if( !Tst_bit( PIND, BUTTON_1 ) && aux == 0 )  
 1e8:	f7 01       	movw	r30, r14
 1ea:	80 81       	ld	r24, Z
 1ec:	82 fd       	sbrc	r24, 2
 1ee:	11 c0       	rjmp	.+34     	; 0x212 <main+0xe6>
 1f0:	11 23       	and	r17, r17
 1f2:	79 f4       	brne	.+30     	; 0x212 <main+0xe6>
    	{
			
			USART_StrTx("Button Pressionado.\r\n");
 1f4:	c3 01       	movw	r24, r6
 1f6:	0e 94 2f 01 	call	0x25e	; 0x25e <USART_StrTx>
			
    		/**
    		 * Inverte o estado lógico do led building;
    		 */
			Cpl_bit( PORTB, LED_BUILDING ); 
 1fa:	f5 01       	movw	r30, r10
 1fc:	80 81       	ld	r24, Z
 1fe:	80 27       	eor	r24, r16
 200:	80 83       	st	Z, r24
 202:	94 01       	movw	r18, r8
 204:	ce 01       	movw	r24, r28
 206:	01 97       	sbiw	r24, 0x01	; 1
 208:	f1 f7       	brne	.-4      	; 0x206 <main+0xda>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 20a:	21 50       	subi	r18, 0x01	; 1
 20c:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 20e:	d1 f7       	brne	.-12     	; 0x204 <main+0xd8>
 210:	13 2d       	mov	r17, r3
			aux = 1; 
		}
		/**
		 * Button solto?
		 */
		if( Tst_bit( PIND, BUTTON_1 ) && aux == 1 )
 212:	f7 01       	movw	r30, r14
 214:	80 81       	ld	r24, Z
 216:	82 ff       	sbrs	r24, 2
 218:	dc cf       	rjmp	.-72     	; 0x1d2 <main+0xa6>
 21a:	11 30       	cpi	r17, 0x01	; 1
 21c:	d1 f6       	brne	.-76     	; 0x1d2 <main+0xa6>
		{
			USART_StrTx("Button Solto.\r\n");
 21e:	c2 01       	movw	r24, r4
 220:	0e 94 2f 01 	call	0x25e	; 0x25e <USART_StrTx>
 224:	94 01       	movw	r18, r8
 226:	ce 01       	movw	r24, r28
 228:	01 97       	sbiw	r24, 0x01	; 1
 22a:	f1 f7       	brne	.-4      	; 0x228 <main+0xfc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 22c:	21 50       	subi	r18, 0x01	; 1
 22e:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 230:	d1 f7       	brne	.-12     	; 0x226 <main+0xfa>
 232:	ce cf       	rjmp	.-100    	; 0x1d0 <main+0xa4>

00000234 <USART_Init>:
#include "usart.h"

void USART_Init()
{
	UBRR0H = (uint8_t) (MYUBRR>>8);				// Ajuste da transmissÃ£o em 9600 bps
 234:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (uint8_t)(MYUBRR);
 238:	87 e6       	ldi	r24, 0x67	; 103
 23a:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);				// Habilita transmissÃ£o e recepÃ§Ã£o
 23e:	88 e1       	ldi	r24, 0x18	; 24
 240:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = (3<<UCSZ00);						// Modo assincrono, 8 bits, 1 stop, sem paridade
 244:	86 e0       	ldi	r24, 0x06	; 6
 246:	80 93 c2 00 	sts	0x00C2, r24
}
 24a:	08 95       	ret

0000024c <USART_Transmit>:
//-------------------------------------------------------------------------------------------------------
void USART_Transmit(unsigned char data)
{
 24c:	98 2f       	mov	r25, r24
	while(!(UCSR0A & (1<<UDRE0)));				// Espera o dado ser enviado
 24e:	e0 ec       	ldi	r30, 0xC0	; 192
 250:	f0 e0       	ldi	r31, 0x00	; 0
 252:	80 81       	ld	r24, Z
 254:	85 ff       	sbrs	r24, 5
 256:	fd cf       	rjmp	.-6      	; 0x252 <USART_Transmit+0x6>
	UDR0 = data;								// Envia o dado pela porta serial
 258:	90 93 c6 00 	sts	0x00C6, r25
}
 25c:	08 95       	ret

0000025e <USART_StrTx>:
	return UDR0;
}

//-------------------------------------------------------------------------------------------------------
void USART_StrTx(const char* ptr)
{
 25e:	cf 93       	push	r28
 260:	df 93       	push	r29
 262:	ec 01       	movw	r28, r24
	while(*ptr != '\0')
 264:	88 81       	ld	r24, Y
 266:	88 23       	and	r24, r24
 268:	31 f0       	breq	.+12     	; 0x276 <USART_StrTx+0x18>
	{
		USART_Transmit(*ptr);
 26a:	0e 94 26 01 	call	0x24c	; 0x24c <USART_Transmit>
		ptr++;
 26e:	21 96       	adiw	r28, 0x01	; 1
}

//-------------------------------------------------------------------------------------------------------
void USART_StrTx(const char* ptr)
{
	while(*ptr != '\0')
 270:	88 81       	ld	r24, Y
 272:	88 23       	and	r24, r24
 274:	d1 f7       	brne	.-12     	; 0x26a <USART_StrTx+0xc>
	{
		USART_Transmit(*ptr);
		ptr++;
	}
}
 276:	df 91       	pop	r29
 278:	cf 91       	pop	r28
 27a:	08 95       	ret

0000027c <USART_rxIE>:
//-------------------------------------------------------------------------------------------------------
void USART_rxIE()
{
	UCSR0B |= (1 << RXCIE0 );
 27c:	e1 ec       	ldi	r30, 0xC1	; 193
 27e:	f0 e0       	ldi	r31, 0x00	; 0
 280:	80 81       	ld	r24, Z
 282:	80 68       	ori	r24, 0x80	; 128
 284:	80 83       	st	Z, r24
}
 286:	08 95       	ret

00000288 <_exit>:
 288:	f8 94       	cli

0000028a <__stop_program>:
 28a:	ff cf       	rjmp	.-2      	; 0x28a <__stop_program>
